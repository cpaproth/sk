# data file for the FLTK User Interface Designer (FLUID)
version 2.1000 
images_dir ../images/ 
header_name {.h} 
code_name {.cpp} 
gridx 5 
gridy 5 
snap 3
decl {//Copyright (C) 2012 Carsten Paproth} {} 

namespace SK {open
} {
  namespace images {} {
    decl {\#include "../images/diamonds.xpm"} {}
    decl {\#include "../images/hearts.xpm"} {}
    decl {\#include "../images/spades.xpm"} {}
    decl {\#include "../images/clubs.xpm"} {}
    decl {fltk::xpmImage dia(diamonds_xpm, "dia");} {}
    decl {fltk::xpmImage hea(hearts_xpm, "hea");} {}
    decl {fltk::xpmImage spa(spades_xpm, "spa");} {}
    decl {fltk::xpmImage clu(clubs_xpm, "clu");} {}
  }
  class UILock {} {
    Function {UILock()} {} {
      code {fltk::lock();} {}
    }
    Function {~UILock()} {} {
      code {fltk::unlock();} {}
    }
  }
  class UserInterface {open
  } {
    decl {fltk::Preferences prefs;} {}
    decl {std::map<std::string, boost::function<void(void)> > f;} {public
    }
    Function {UserInterface(void):prefs(fltk::Preferences::USER, "cpaproth", "sk")} {open
    } {
      code {UILock lock;} {}
      {fltk::Window} mainwnd {
        label {Skat-Konferenz}
        callback {mainwnd->hide();} open
        private xywh {93 32 960 700} resizable
        extra_code {\#include <map>
\#include <string>
\#include <boost/function/function0.hpp>
\#include <fltk/run.h>
\#include <fltk/Preferences.h>
\#include <fltk/xpmImage.h>
\#include "LogDisplay.h"
\#include "GlImage.h"
\#include "GlTable.h"
\#include "BidButton.h"} visible
      } {
        {fltk::TabGroup} {} {open
          xywh {0 0 960 700}
        } {
          {fltk::Group} {} {
            label Spiel open selected
            xywh {0 25 960 675}
          } {
            {fltk::InvisibleBox} table {
              callback {f["table event"]();}
              xywh {0 240 640 435} box FLAT_BOX color 0x71c67100
              class GlTable
            }
            {fltk::InvisibleBox} leftimage {
              xywh {0 0 320 240} box FLAT_BOX color 56
              class GlImage
            }
            {fltk::InvisibleBox} rightimage {
              xywh {320 0 320 240} box FLAT_BOX color 56
              class GlImage
            }
            {fltk::InvisibleBox} midimage {
              xywh {640 435 320 240} box FLAT_BOX color 56
              class GlImage
            }
            {fltk::Group} {} {open
              xywh {640 0 320 85} box DOWN_BOX
            } {
              {fltk::Button} bid {
                label Reizen
                callback {f["game bid"]();}
                xywh {40 45 105 25} buttonbox PLASTIC_UP_BOX labelfont 1 buttoncolor 0xff0000
                class BidButton
              }
              {fltk::Button} fold {
                label Passen
                callback {f["game fold"]();}
                xywh {175 45 105 25} buttonbox PLASTIC_UP_BOX labelfont 1 buttoncolor 0xff000000
              }
              {fltk::InvisibleBox} info {
                label Information
                xywh {0 10 320 25} align 32 labelfont 1
              }
            }
            {fltk::Group} {} {open
              xywh {640 85 320 240} when NEVER box DOWN_BOX
            } {
              {fltk::InvisibleBox} gameinfo {
                label Spielinfo
                xywh {0 10 320 25} align 32 labelfont 1
              }
              {fltk::Group} {} {open
                xywh {60 45 200 70} when NEVER
              } {
                {fltk::Button} diamonds {
                  label {@dia}
                  callback {f["game select"]();}
                  tooltip {Karo ist Trumpf.}
                  xywh {0 0 50 35} type RADIO value 1
                  extra_code {diamonds->take_focus();}
                }
                {fltk::Button} hearts {
                  label {@hea}
                  callback {f["game select"]();}
                  tooltip {Herz ist Trumpf.}
                  xywh {50 0 50 35} type RADIO
                }
                {fltk::Button} spades {
                  label {@spa}
                  callback {f["game select"]();}
                  tooltip {Pik ist Trumpf.}
                  xywh {100 0 50 35} type RADIO
                }
                {fltk::Button} clubs {
                  label {@clu}
                  callback {f["game select"]();}
                  tooltip {Kreuz ist Trumpf.}
                  xywh {150 0 50 35} type RADIO
                }
                {fltk::Button} grand {
                  label Grand
                  callback {f["game select"]();}
                  tooltip {Nur Buben sind Trumpf.}
                  xywh {0 35 60 35} type RADIO labelfont 1
                }
                {fltk::Button} null {
                  label Null
                  callback {f["game select"]();}
                  tooltip {Nullspiel, es gibt kein Trumpf.}
                  xywh {60 35 45 35} type RADIO labelfont 1
                }
                {fltk::Button} nullouvert {
                  label {Null Ouvert}
                  callback {f["game select"]();}
                  tooltip {Offenes Nullspiel, es gibt kein Trumpf.}
                  xywh {105 35 95 35} type RADIO labelfont 1
                }
              }
              {fltk::Group} hand {open
                xywh {60 115 200 35} when NEVER
              } {
                {fltk::Button} schneider {
                  label Schneider
                  callback {if (!schneider->value()) {
  schwarz->value(false);
  ouvert->value(false);
}
f["game select"]();}
                  tooltip {Handspiel, Schneider angesagt.}
                  xywh {0 0 80 35} type TOGGLE labelfont 1
                }
                {fltk::Button} schwarz {
                  label Schwarz
                  callback {if (schwarz->value())
  schneider->value(true);
else
  ouvert->value(false);
f["game select"]();}
                  tooltip {Handspiel, Schneider und Schwarz angesagt.}
                  xywh {80 0 65 35} type TOGGLE labelfont 1
                }
                {fltk::Button} ouvert {
                  label Ouvert
                  callback {if (ouvert->value()) {
  schneider->value(true);
  schwarz->value(true);
}
f["game select"]();}
                  tooltip {Offenes Handspiel, Schneider und Schwarz angesagt.}
                  xywh {145 0 55 35} type TOGGLE labelfont 1
                }
              }
              {fltk::Button} skat {
                label {Skat aufnehmen}
                callback {f["skat take"]();}
                tooltip {Kein Handspiel.}
                xywh {60 160 200 25} labelfont 1
              }
              {fltk::Button} announce {
                label {Spiel ansagen}
                callback {f["game announce"]();}
                xywh {60 195 200 25} labelfont 1
              }
            }
            {fltk::Group} {} {open
              xywh {640 325 320 110} box DOWN_BOX
            } {
              {fltk::Button} dealout {
                label {Karten austeilen}
                callback {f["game dealout"]();}
                xywh {30 20 115 25}
              }
              {fltk::Button} disclose {
                label {Karten aufdecken}
                callback {f["game disclose"]();}
                xywh {30 65 115 25}
              }
              {fltk::Button} contrare {
                label {Kontra / Re}
                callback {f["game contrare"]();}
                xywh {175 20 115 25} type TOGGLE
              }
              {fltk::Button} giveup {
                label {Spiel aufgeben}
                callback {f["game giveup"]();}
                xywh {175 65 115 25} type TOGGLE
              }
            }
          }
          {fltk::Group} {} {
            label System open
            xywh {0 25 960 675} hide
          } {
            {fltk::Group} {} {
              label Audio open
              xywh {630 85 220 145} align 33 box DOWN_BOX labeltype ENGRAVED_LABEL
            } {
              {fltk::Button} {} {
                label {Neustart Audiostream}
                callback {f["audio restart"]();}
                tooltip {Falls der Audiostream verzögert läuft, kann ein Neustart dies evtl. beheben. Zeigt zusätzlich die gegenwärtige CPU Auslastung des Audiostreams im Log-Fenster an.}
                private xywh {35 40 150 25}
              }
              {fltk::CheckButton} {} {
                label {Mikrofon abspielen}
                callback {f["audio toggle"]();}
                tooltip {Wenn aktiviert, dann wird die Mikrofonaufnahme nicht übers Netzwerk gesendet, sondern direkt abgespielt. Kann nützlich sein um den Mixer richtig einstellen zu können, damit z.B. Echos verringert werden. }
                xywh {35 90 150 25}
              }
            }
            {fltk::Group} {} {
              label Netzwerk open
              xywh {90 60 390 290} align 33 box DOWN_BOX labeltype ENGRAVED_LABEL
            } {
              {fltk::Input} address {
                label {IP-Adresse}
                callback {prefs.set("ipaddress", address->value());}
                tooltip {Das Feld leer lassen, um beim Verbinden des Netzwerks als Server zu dienen. Damit sich andere Spieler als Clients mit diesem Server verbinden können, musst du ihnen die öffentlich erreichbare IP-Adresse und den ausgewählten UDP-Port mitteilen.}
                xywh {165 40 195 25}
                extra_code {char* c;
prefs.get("ipaddress", c, "");
address->value(c);
delete[] c;}
              }
              {fltk::ValueInput} port {
                label {UDP-Port}
                callback {if (port->value() < 0)
  port->value(0);
if (port->value() > 65535)
  port->value(65535);
prefs.set("udpport", port->value());}
                tooltip {Um einen Server mit einer Portnummer kleiner als 1024 zu starten, benötigt man evtl. Root-Rechte.}
                xywh {165 90 195 25} when RELEASE color 0xffffff00 maximum 65535 step 1
                extra_code {double d;
prefs.get("udpport", d, 34588);
port->value(d);}
              }
              {fltk::ValueInput} bandwidth {
                label {Video Upload-Bandbreite}
                callback {if (bandwidth->value() < 0)
  bandwidth->value(0);
prefs.set("bandwidth", bandwidth->value());}
                tooltip {Maximale Upload-Bandbreite für Video in Byte/s, wird auf die verbundenen Peers aufgeteilt. Der Audiostream benötigt pro Peer immer 2500 Byte/s, sonstiger Netzwerkverkehr ist weniger als 1000 Byte/s pro Peer.}
                xywh {165 140 195 25} when RELEASE color 0xffffff00 maximum 1e+09 step 1
                extra_code {double d;
prefs.get("bandwidth", d, 50000);
bandwidth->value(d);
bandwidth->linesize(1000);}
              }
              {fltk::Button} {} {
                label Verbinden
                callback {f["network connect"]();}
                tooltip {Wenn das IP-Adressenfeld leer ist, dann startest du hiermit die Skat-Konferenz als Server, ansonsten wird eine Verbindung zu der angegebenen IP-Adresse und UDP-Port aufgebaut. Wenn die Verbindung erfolgreich ist, dann beginnt die Videokonferenz. Wenn 3 Peers miteinander verbunden sind, dann startet das Spiel.}
                xywh {165 190 195 25}
              }
              {fltk::Button} {} {
                label Stats
                callback {f["network stats"]();}
                tooltip {Gibt ein paar Statistiken über die verbundenen Peers im Log-Fenster aus.}
                xywh {165 240 195 25}
              }
              {fltk::CheckButton} autoconnect {
                label Auto
                callback {prefs.set("autoconnect", autoconnect->value());}
                tooltip {Wenn aktiviert, dann wird das Netzwerk beim nächsten Programmstart automatisch verbunden. Nur sinnvoll beim Start als Server oder bei Verbindung zu statischer IP-Adresse.}
                xywh {70 190 60 25}
                extra_code {int i;
prefs.get("autoconnect", i, 0);
autoconnect->value(i != 0);}
              }
            }
            {fltk::Group} {} {
              label Benutzer open
              xywh {525 295 265 135} align 33 box DOWN_BOX labeltype ENGRAVED_LABEL
            } {
              {fltk::Input} name {
                label Spielername
                callback {prefs.set("username", name->value());
f["name change"]();}
                tooltip {Dein Spielername.}
                xywh {85 40 165 25}
                extra_code {char* c;
prefs.get("username", c, "nobody");
name->value(c);
delete[] c;}
              }
              {fltk::Input} secret {
                label Geheimnis
                callback {prefs.set("secret", secret->value());}
                tooltip {Wird zusätzlich zur Zeit verwendet um den Zufallsgenerator zu initialisieren.}
                xywh {85 85 165 25}
                extra_code {char* c;
prefs.get("secret", c, "");
secret->value(c);
delete[] c;}
              }
            }
            {fltk::Group} {} {
              label Sonderregeln open
              tooltip {Es gelten die Regeln der internationalen Skatordnung. Es sind nur die Sonderregeln wirksam, die bei allen Spielern aktiviert sind. Ramsch wird ohne Schieben, Grand Ouvert oder Durchmarsch gespielt. Der Spieler mit den wenigsten Augen gewinnt das Ramsch-Spiel mit 23 Punkten, macht er gar keinen Stich, gewinnt er mit 46 Punkten.}
              xywh {170 400 275 175} align 33 box DOWN_BOX labeltype ENGRAVED_LABEL
            } {
              {fltk::CheckButton} foldrule {
                label {Ramschen statt Einpassen}
                callback {prefs.set("rulefold", foldrule->value());
f["rule change"]();}
                tooltip {Wenn alle Spieler passen, wird mit der Hand Ramsch gespielt.}
                xywh {25 40 190 25}
                extra_code {int i;
prefs.get("rulefold", i, 0);
foldrule->value(i != 0);}
              }
              {fltk::CheckButton} contrarerule {
                label {Kontra und Re}
                callback {prefs.set("rulecontrare", contrarerule->value());
f["rule change"]();}
                tooltip {Gegenspieler, die nicht bei 18 gepasst haben, dürfen bis zur 4. ausgespielten Karte Kontra sagen. Der Alleinspieler darf daraufhin Re bis zur 7. ausgespielten Karte sagen. Kontra und Re verdoppeln jeweils die Punktzahl des Spiels.}
                xywh {25 70 120 25}
                extra_code {int i;
prefs.get("rulecontrare", i, 0);
contrarerule->value(i != 0);}
              }
              {fltk::CheckButton} bockrule {
                label Bockrunde
                callback {prefs.set("rulebock", bockrule->value());
f["rule change"]();}
                tooltip {In einer Bockrunde werden die Punkte jedes Spiels verdoppelt. Eine Bockrunde wird gespielt nach verlorenem Kontra-Spiel, Kontra-Re-Spiel, Spiel mit 60 zu 60 Augen oder gewonnenem Spiel mit wenigstens 100 Punkten Grundwert.}
                xywh {25 100 100 25}
                extra_code {int i;
prefs.get("rulebock", i, 0);
bockrule->value(i != 0);}
              }
              {fltk::CheckButton} junkrule {
                label Ramschrunde
                callback {prefs.set("rulejunk", junkrule->value());
f["rule change"]();}
                tooltip {Eine Ramschrunde wird unter den gleichen Bedingungen wie eine Bockrunde ausgelöst. Auch hier werden die Punkte der Spiele verdoppelt, allerdings ist jedes Spiel Ramsch. Wenn Bock- und Ramschrunden gespielt werden sollen, dann folgt die Ramsch- auf die Bockrunde.}
                xywh {25 130 110 25}
                extra_code {int i;
prefs.get("rulejunk", i, 0);
junkrule->value(i != 0);}
              }
            }
          }
          {fltk::Group} {} {
            label Log open
            xywh {0 25 960 675} hide
          } {
            {fltk::TextDisplay} {} {
              private xywh {0 0 480 675}
              class LogDisplay
            }
            {fltk::Browser} listing {open
              xywh {480 0 480 675}
              extra_code {const int widths[] = {150, 50, 80, 80, 80, -1, 0};
const char* labels[] = {"Spiel", "Punkte", "Du", "Links", "Rechts", "", 0};
listing->column_widths(widths);
listing->column_labels(labels);}
            } {}
          }
        }
      }
      code {w->remove_shortcuts();} {}
      code {w->resizable(0);} {}
      code {w->show();} {}
    }
    Function {~UserInterface(void)} {} {
      code {delete mainwnd;} {}
    }
    Function {UserInterface(const UserInterface&):prefs("", "", "")} {private
    } {}
    Function {operator=(const UserInterface&)} {private
    } {}
  }
} 
