# data file for the FLTK User Interface Designer (FLUID)
version 2.1000 
images_dir ../images/ 
header_name {.h} 
code_name {.cpp} 
gridx 5 
gridy 5 
snap 3
decl {//Copyright (C) 2012 Carsten Paproth} {} 

namespace SK {open
} {
  namespace images {} {
    decl {\#include "../images/diamonds.xpm"} {}
    decl {\#include "../images/hearts.xpm"} {}
    decl {\#include "../images/spades.xpm"} {}
    decl {\#include "../images/clubs.xpm"} {}
    decl {fltk::xpmImage dia(diamonds_xpm, "dia");} {}
    decl {fltk::xpmImage hea(hearts_xpm, "hea");} {}
    decl {fltk::xpmImage spa(spades_xpm, "spa");} {}
    decl {fltk::xpmImage clu(clubs_xpm, "clu");} {}
  }
  class UILock {} {
    Function {UILock()} {} {
      code {fltk::lock();} {}
    }
    Function {~UILock()} {} {
      code {fltk::unlock();} {}
    }
  }
  class UIUnlock {} {
    Function {UIUnlock()} {} {
      code {fltk::unlock();} {}
    }
    Function {~UIUnlock()} {} {
      code {fltk::lock();} {}
    }
  }
  class UserInterface {open
  } {
    decl {fltk::Preferences prefs;} {}
    decl {std::map<std::string, boost::function<void(void)> > f;} {public
    }
    Function {UserInterface(void):prefs(fltk::Preferences::USER, "cpaproth", "sk")} {open
    } {
      code {UILock lock;} {}
      {fltk::Window} mainwnd {
        label {Skat-Konferenz}
        callback {mainwnd->hide();} open
        private xywh {93 105 960 700} resizable
        extra_code {\#include <map>
\#include <string>
\#include <boost/function/function0.hpp>
\#include <fltk/run.h>
\#include <fltk/Preferences.h>
\#include <fltk/xpmImage.h>
\#include "GlImage.h"
\#include "GlTable.h"
\#include "BidButton.h"} visible
      } {
        {fltk::TabGroup} {} {open
          xywh {0 0 960 700}
        } {
          {fltk::Group} {} {
            label Spiel open
            xywh {0 25 960 675}
          } {
            {fltk::InvisibleBox} table {
              callback {f["table event"]();} selected
              xywh {0 240 640 435} box FLAT_BOX color 0x71c67100
              class GlTable
            }
            {fltk::InvisibleBox} leftimage {
              xywh {0 0 320 240} box FLAT_BOX color 56
              class GlImage
            }
            {fltk::InvisibleBox} rightimage {
              xywh {320 0 320 240} box FLAT_BOX color 56
              class GlImage
            }
            {fltk::InvisibleBox} midimage {
              xywh {640 435 320 240} box FLAT_BOX color 56
              class GlImage
            }
            {fltk::Group} {} {open
              xywh {640 0 320 110} box DOWN_BOX
            } {
              {fltk::Button} bid {
                label Reizen
                callback {f["game bid"]();}
                xywh {40 60 105 25} buttonbox PLASTIC_UP_BOX labelfont 1 buttoncolor 0xff0000
                class BidButton
              }
              {fltk::Button} fold {
                label Passen
                callback {f["game fold"]();}
                xywh {175 60 105 25} buttonbox PLASTIC_UP_BOX labelfont 1 buttoncolor 0xff000000
              }
              {fltk::InvisibleBox} info {
                label Information
                xywh {0 20 320 25} align 32 labelfont 1
              }
            }
            {fltk::Group} {} {open
              xywh {640 110 320 240} when NEVER box DOWN_BOX
            } {
              {fltk::InvisibleBox} gameinfo {
                label Spielinfo
                xywh {0 10 320 25} align 32 labelfont 1
              }
              {fltk::Group} trump {
                xywh {60 45 200 70} when NEVER
              } {
                {fltk::Button} diamonds {
                  label {@dia}
                  callback {f["game select"]();}
                  tooltip {Karo ist Trumpf.}
                  xywh {0 0 50 35} type RADIO value 1
                }
                {fltk::Button} hearts {
                  label {@hea}
                  callback {f["game select"]();}
                  tooltip {Herz ist Trumpf.}
                  xywh {50 0 50 35} type RADIO
                }
                {fltk::Button} spades {
                  label {@spa}
                  callback {f["game select"]();}
                  tooltip {Pik ist Trumpf.}
                  xywh {100 0 50 35} type RADIO
                }
                {fltk::Button} clubs {
                  label {@clu}
                  callback {f["game select"]();}
                  tooltip {Kreuz ist Trumpf.}
                  xywh {150 0 50 35} type RADIO
                }
                {fltk::Button} grand {
                  label Grand
                  callback {f["game select"]();}
                  tooltip {Buben sind Trumpf.}
                  xywh {0 35 60 35} type RADIO labelfont 1
                }
                {fltk::Button} null {
                  label Null
                  callback {f["game select"]();}
                  tooltip {Nullspiel, nichts ist Trumpf.}
                  xywh {60 35 45 35} type RADIO labelfont 1
                }
                {fltk::Button} nullouvert {
                  label {Null Ouvert}
                  callback {f["game select"]();}
                  tooltip {Offenes Nullspiel.}
                  xywh {105 35 95 35} type RADIO labelfont 1
                }
              }
              {fltk::Group} hand {open
                xywh {60 115 200 35} when NEVER
              } {
                {fltk::Button} schneider {
                  label Schneider
                  callback {if (!schneider->value()) {
  schwarz->value(false);
  ouvert->value(false);
}
f["game select"]();}
                  tooltip {Handspiel, Schneider angesagt.}
                  xywh {0 0 80 35} type TOGGLE labelfont 1
                }
                {fltk::Button} schwarz {
                  label Schwarz
                  callback {if (schwarz->value())
  schneider->value(true);
else
  ouvert->value(false);
f["game select"]();}
                  tooltip {Handspiel, Schwarz angesagt.}
                  xywh {80 0 65 35} type TOGGLE labelfont 1
                }
                {fltk::Button} ouvert {
                  label Ouvert
                  callback {if (ouvert->value()) {
  schneider->value(true);
  schwarz->value(true);
}
f["game select"]();}
                  tooltip {Offenes Handspiel.}
                  xywh {145 0 55 35} type TOGGLE labelfont 1
                }
              }
              {fltk::Button} skat {
                label {Skat aufnehmen}
                callback {f["skat take"]();}
                tooltip {Kein Handspiel.}
                xywh {60 160 200 25} labelfont 1
              }
              {fltk::Button} announce {
                label {Spiel ansagen}
                callback {f["game announce"]();}
                xywh {60 195 200 25} labelfont 1
              }
            }
            {fltk::Group} {} {open
              xywh {640 350 320 85} box DOWN_BOX
            } {
              {fltk::Button} {} {
                label Austeilen
                callback {f["dealing start"]();}
                xywh {105 30 105 25}
              }
            }
          }
          {fltk::Group} {} {
            label Liste open
            xywh {0 25 960 675} hide
          } {}
          {fltk::Group} {} {
            label System open
            xywh {0 25 960 675} hide
          } {
            {fltk::Group} {} {
              label Audio open
              xywh {630 85 220 145} align 33 box DOWN_BOX labeltype ENGRAVED_LABEL
            } {
              {fltk::Button} {} {
                label {Neustart Audiostream}
                callback {f["audio restart"]();}
                tooltip {Falls der Audiostream verzögert läuft, kann ein Neustart dies evtl. beheben. Zeigt zusätzlich die gegenwärtige CPU Auslastung des Audiostreams im Log-Fenster an.}
                private xywh {35 40 150 25}
              }
              {fltk::CheckButton} {} {
                label {Mikrofon abspielen}
                callback {f["audio toggle"]();}
                tooltip {Wenn aktiviert, dann wird die Mikrofonaufnahme nicht übers Netzwerk gesendet, sondern direkt abgespielt. Kann nützlich sein um den Mixer richtig einstellen zu können, damit z.B. Echos verringert werden. }
                xywh {35 90 150 25}
              }
            }
            {fltk::Group} {} {
              label Netzwerk open
              xywh {90 60 390 290} align 33 box DOWN_BOX labeltype ENGRAVED_LABEL
            } {
              {fltk::Input} address {
                label {IP-Adresse}
                callback {prefs.set("ipaddress", address->value());}
                tooltip {Das Feld leer lassen, um beim Verbinden des Netzwerks als Server zu dienen. Damit sich andere Spieler als Clients mit ihrem Server verbinden können, müssen sie ihnen ihre öffentlich erreichbare IP-Adresse und den ausgewählten UDP-Port mitteilen.}
                xywh {165 40 195 25}
                extra_code {char* c;
prefs.get("ipaddress", c, "");
address->value(c);
delete[] c;}
              }
              {fltk::ValueInput} port {
                label {UDP-Port}
                callback {if (port->value() < 0)
  port->value(0);
if (port->value() > 65535)
  port->value(65535);
prefs.set("udpport", port->value());}
                tooltip {Um einen Server mit einer Portnummer kleiner als 1024 zu starten, benötigt man evtl. Root-Rechte.}
                xywh {165 90 195 25} when RELEASE color 0xffffff00 maximum 65535 step 1
                extra_code {double d;
prefs.get("udpport", d, 34588);
port->value(d);}
              }
              {fltk::ValueInput} bandwidth {
                label {Video Upload-Bandbreite}
                callback {if (bandwidth->value() < 0)
  bandwidth->value(0);
prefs.set("bandwidth", bandwidth->value());}
                tooltip {Maximale Upload-Bandbreite für Video in Byte/s, wird auf die verbundenen Peers aufgeteilt. Der Audiostream benötigt pro Peer immer 2500 Byte/s, sonstiger Netzwerkverkehr ist weniger als 1000 Byte/s pro Peer.}
                xywh {165 140 195 25} when RELEASE color 0xffffff00 maximum 1e+09 step 1
                extra_code {double d;
prefs.get("bandwidth", d, 50000);
bandwidth->value(d);
bandwidth->linesize(1000);}
              }
              {fltk::Button} {} {
                label Verbinden
                callback {f["network start"]();}
                tooltip {Wenn keine IP-Adresse angegeben ist, dann starten sie hiermit die Skat-Konferenz als Server, ansonsten wird eine Verbindung zu der angegebenen IP-Adresse und UDP-Port aufgebaut. Wenn die Verbindung erfolgreich ist, dann beginnt die Videokonferenz. Wenn 3 Peers miteinander verbunden sind, dann startet das Spiel.}
                xywh {165 190 195 25}
              }
              {fltk::Button} {} {
                label Stats
                callback {f["network stats"]();}
                tooltip {Gibt ein paar Statistiken über die verbundenen Peers im Log-Fenster aus.}
                xywh {165 240 195 25}
              }
              {fltk::CheckButton} autostart {
                label Auto
                callback {prefs.set("autostart", autostart->value());}
                tooltip {Wenn aktiviert, dann wird das Netzwerk beim nächsten Programmstart automatisch verbunden. Nur sinnvoll beim Start als Server oder bei Verbindung zu statischer IP-Adresse.}
                xywh {70 190 60 25}
                extra_code {int i;
prefs.get("autostart", i, 0);
autostart->value(i != 0);}
              }
            }
            {fltk::Group} {} {
              label Spiel open
              xywh {525 295 265 150} align 33 box DOWN_BOX labeltype ENGRAVED_LABEL
            } {
              {fltk::Input} name {
                label Spielername
                callback {prefs.set("username", name->value());
f["name change"]();}
                tooltip {Ihr Spielername.}
                xywh {85 40 165 25}
                extra_code {char* c;
prefs.get("username", c, "nobody");
name->value(c);
delete[] c;}
              }
              {fltk::Input} secret {
                label Geheimnis
                callback {prefs.set("secret", secret->value());}
                tooltip {Wird zusätzlich zur Zeit verwendet um den Zufallsgenerator zu initialisieren.}
                xywh {85 85 165 25}
                extra_code {char* c;
prefs.get("secret", c, "");
secret->value(c);
delete[] c;}
              }
            }
          }
          {fltk::Group} {} {
            label Log open
            xywh {0 25 960 675} hide
          } {
            {fltk::TextDisplay} log {
              xywh {0 0 960 675}
            }
          }
        }
      }
      code {w->resizable(0);} {}
      code {w->show();} {}
    }
    Function {~UserInterface(void)} {} {
      code {delete mainwnd;} {}
    }
    Function {UserInterface(const UserInterface&):prefs("", "", "")} {private
    } {}
    Function {operator=(const UserInterface&)} {private
    } {}
  }
} 
